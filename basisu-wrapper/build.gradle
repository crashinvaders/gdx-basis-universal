apply plugin: 'java-library'

java {
    sourceCompatibility = JavaVersion.VERSION_1_8
    targetCompatibility = JavaVersion.VERSION_1_8
}

compileJava.options.incremental = true
compileJava.options.headerOutputDirectory.set(file('jni'))

sourceSets.main.java.srcDirs += ['src']
sourceSets.test.java.srcDirs += ['test']
sourceSets.test.resources.srcDirs += ['test-resources']

dependencies {
    testImplementation "junit:junit:$junitVersion"
    testImplementation "com.badlogicgames.gdx:gdx-jnigen-loader:$jnigenVersion"
    testRuntimeOnly files("${project(':basisu-wrapper').buildDir}/libs/basisu-wrapper-${version}-natives-desktop.jar")
}

test {
    useJUnit()
    maxHeapSize = '1G'
}

//region jnigen configuration
apply plugin: 'com.badlogicgames.gdx.gdx-jnigen'

def nativeSrcFiles = [
        'basisu_wrapper.cpp',
        'basisu_native_utils.cpp',
        'basis-universal/transcoder/basisu_transcoder.cpp',
        'com_crashinvaders_basisu_wrapper_BasisuWrapper.cpp',
        'com_crashinvaders_basisu_wrapper_BasisuFileInfo.cpp',
        'com_crashinvaders_basisu_wrapper_BasisuImageInfo.cpp',
]

// The set of supported native GPU texture formats varies based on the platform.
// "-DBASISD_SUPPORT_*" flag params disable specific transcoder texture tables to save up space.
// Unity docs have a nice reference page - https://docs.unity3d.com/Manual/class-TextureImporterOverride.html
//
// Desktop
// Essentially supports everything (or it's more accurate to say ANYTHING), so we need them all.
// Except for a few mobile-first GPU specific formats.
def desktopUnsupportedFormats = ' -DBASISD_SUPPORT_PVRTC1=0 '

// Web (WebGL) - all the disabled texture types hardcoded in the jni/build-web.xml Ant script file.
// https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Compressed_texture_formats
// SUPPORTED TEXTURES: [ASTC, ETC1, ETC2, PVRTC1, DXT]

jnigen {
    sharedLibName = 'gdx-basis-universal'

    nativeCodeGenerator {
        sourceDir = '/src'
    }

    all {
        headerDirs = ['include', 'basis-universal/transcoder']
        cExcludes = cppExcludes = ['build/**',]

        cppIncludes = nativeSrcFiles

        cFlags +=      ' -std=c11   -fvisibility=hidden -Wall -O2 -g0 -fno-exceptions '
        cppFlags +=    ' -std=c++11 -fvisibility=hidden -Wall -O2 -g0 -fno-exceptions '
        linkerFlags += '            -fvisibility=hidden -Wall -O2 -g0 -fno-exceptions '

        // Disable texture formats we don't support at all.
        // Macros reference - https://github.com/BinomialLLC/basis_universal/wiki/Transcoder-details-and-shrinking-the-compiled-size-of-the-transcoder#shrinking-the-transcoders-compiled-size
        cppFlags += ' -DBASISD_SUPPORT_FXT1=0 '

        // Enable for Basis Universal debug messages.
        // cppFlags += ' -DBASISU_FORCE_DEVEL_MESSAGES=1 '
    }
    add(Windows, x32) {
        compilerPrefix = 'mingw32-'
        compilerSuffix = '.exe'

        linkerFlags += ' -s '   // Strip debug symbols.
        cppFlags += desktopUnsupportedFormats

    }
    add(Windows, x64) {
        compilerSuffix = '.exe'

        linkerFlags += ' -s '   // Strip debug symbols.
        cppFlags += desktopUnsupportedFormats
    }
    add(Linux, x32) {
        cppFlags += desktopUnsupportedFormats
    }
    add(Linux, x64) {
        cppFlags += desktopUnsupportedFormats
    }
    add(Linux, x32, ARM) {
        cppFlags += desktopUnsupportedFormats
    }
    add(Linux, x64, ARM) {
        cppFlags += desktopUnsupportedFormats
    }
    add(MacOsX, x64) {
        cppFlags += desktopUnsupportedFormats
    }
    add(Android) {
        linkerFlags += ' -llog '  // We use "log.h" lib and should explicitly declare it.

        // Android
        // SUPPORTED TEXTURES: [ASTC, ETC1, ETC2, DXT, ATC, PVRTC1 and PVRTC2]
        cppFlags += ' -DBASISD_SUPPORT_BC7=0 '
        cppFlags += ' -DBASISD_SUPPORT_BC7_MODE5=0 '

        // Should be in sync with the official supported ABI list.
        // https://developer.android.com/ndk/guides/abis#sa
        androidABIs = ['armeabi-v7a', 'arm64-v8a', 'x86', 'x86_64']
    }
    add(IOS) {
        cppFlags += ' -stdlib=libc++ '  // iOS compiler toolchain is pretty whiny about this...


        // iOS
        // SUPPORTED TEXTURES: [ASTC, ETC1, ETC2, PVRTC1]
        cppFlags += ' -DBASISD_SUPPORT_DXT1=0 '
        cppFlags += ' -DBASISD_SUPPORT_DXT5A=0 '
        cppFlags += ' -DBASISD_SUPPORT_BC7=0 '
        cppFlags += ' -DBASISD_SUPPORT_BC7_MODE5=0 '
        cppFlags += ' -DBASISD_SUPPORT_ATC=0 '
        cppFlags += ' -DBASISD_SUPPORT_PVRTC2=0 '
    }
}

getTasksByName('jnigen', false).first().doLast {
    //FIXME Remove this once "jnigen" task creates "libs" under the respected module (currently it writes to the root project dir).
    if (file("${rootDir}/libs").exists()) {
        println "Applying libs dir fix..."
        ant.move file: "${rootDir}/libs",
                todir: "${projectDir}"
    }

    // Update "ndkSuffix" Android build property with platform specific file suffix.
    if (org.gradle.internal.os.OperatingSystem.current().isWindows()) {
        ant.replaceregexp(
                match: '<property name="ndkSuffix" value="" />',
                replace: '<property name="ndkSuffix" value=".cmd" />',
                flags: 'g',
                byline: true) {
            fileset(dir: 'jni', includes: 'build-android32.xml')
        }
    }

    // Fix missing source files in Android.mk.
    ant.replaceregexp(
            match: 'LOCAL_SRC_FILES :=  ',
            replace: "LOCAL_SRC_FILES := ${String.join(' ', nativeSrcFiles)}\n",
            flags: 'g',
            byline: true) {
        fileset(dir: 'jni', includes: 'Android.mk')
    }
}

task jnigenBuildWeb() {
    group 'jnigen'
    description 'Executes jnigen build script for build target web (JS + WASM).'

    // This is pretty much the direct copy of JnigenBuildTargetTask#run() code.
    doFirst {
        if (!com.badlogic.gdx.jnigen.BuildExecutor.executeAnt(
                "${projectDir}/jni/build-web.xml",
                "-Drelease=" + jnigen.release, "clean", "postcompile", "-v")) {
            throw new RuntimeException("Ant execution for web failed.");
        }
    }
}

task jnigenJarNativesWeb(type: Jar) {
    group 'jnigen'
    description 'Assembles a jar archive containing the web native libraries.'

    archiveBaseName = project.name
    archiveVersion = project.version
    archiveClassifier = 'natives-web'

    from "${projectDir}/${jnigen.libsDir}/web"
    from "${projectDir}/${jnigen.jniDir}/BasisuWrapperNatives.gwt.xml"
}

task jnigenJarNativesAll {
    group 'jnigen'
    description 'Assembles jar archives native libraries for all the supported platforms.'

    dependsOn jnigenJarNativesDesktop
    dependsOn jnigenJarNativesIOS
    dependsOn jnigenJarNativesWeb
    // Include all the Android ABI jars.
    jnigenJarNativesAndroid.dependsOn.forEach { androidAbiJarNativesTask ->
        dependsOn androidAbiJarNativesTask
    }
}

//// Android native jar tasks are all have pretty misleading classifier of "natives-$ABI".
//// Lets patch it up to make the naming a bit more canonical (e.g. "natives-android-$ABI").
//jnigenJarNativesAndroid.dependsOn.forEach { task ->
//    String origClassifier = task.archiveClassifier.get()
//    String patchedClassifier = origClassifier.replace('natives-', 'natives-android-')
//    task.archiveClassifier = patchedClassifier
//}

//// Import native build Ant tasks.
//if (file('jni/build.xml').exists()) {
//    println 'Importing ANT tasks from \"jni/build.xml\"'
//    ant.importBuild('jni/build.xml') { antTargetName ->
//        def taskName = 'jnigenAntBuild-' + antTargetName
//        println "\"$taskName\" ANT task has been imported."
//        taskName
//    }
//}

//endregion

// Define all the natives jars so Maven can pickup those and publish.
artifacts {
    jnigenJarNativesAll.dependsOn.forEach { jarNativesTask ->
        archives jarNativesTask
    }
}